# todo:
## sorted:
- [ ] SecureEndpointMiddleware should be allowed to pass a custom validation function
    - It'd take the AuthUser as the parameter
    - Useful for things like validating users have authorization to specific sections of features based on application logic
- [ ] Make URL redirects dynamic
    - e.g. modify redirect for successful auth, let API endpoints be changed for components
    - Maybe set this on `LoginHandler{}` and `RegistrationHandler{}`?
- [ ] Password Policies set on Server
    - Set on `RegistrationHandler{}`
- [ ] Secure registration & login endpoints
    - Only allow requests from the same domain.
    - Flag to DISABLE this on `LoginHandler{}`
- [ ] Multifactor support
    - [ ] WebAuthn support
    - [ ] TOTP support
    - [ ] Email sign in link
    - [ ] Option to require MFA on sign up
- [ ] User lockout policy (invalid passwords, etc)
    - Set on `LoginHandler{}`
- [ ] Attach a "Device Cookie" to the token system. If a user logs in on the same device, log them out of their previous session.
- [ ] Save last active time to Session
- [ ] Trust Device
    - Assign a name to the device
    - Mark device as trusted in Sessions
    - Maybe here is where we should auto-renew the token?
- [ ] User page
    - [ ] Let user delete account
    - [ ] View active sessions (connected IP, lease)
        - [ ] Kill a session
    - [ ] Reset passwords

## unsorted:
- [ ] Different Launchpads based on environment variable
    - This would be useful to define a ton of edge cases in development, and then limit the amount of users in staging environments.
    - LocksmithLaunchpadOptions.Users needs to be read in through a `.launchpad.env` file. Once `InitializeLaunchpad` is called, it will read in `USER_0` as a CSV (Username,DisplayName,Email,Role,Redirect), and then look for `USER_X` until it has read them all in.
    - This will make it less hard-coded, and make it so even less data is "leaked" in the production binary.
- [ ] Use `CompileLocksmithPassword` for the Launchpad access token
    - If there is no access token present in the ENV_VAR file, the `InitializeLaunchpad` would prompt you for input asking what the access token should be, and then write the password to the file. No more plaintext!
- [ ] Have the app yell at you if you have too wide of permissions of the `.launchpad.env` file
- [ ] Launchpad Persona Groups
    - e.g. "Internal users" would have their own column on the Launchpage, "Public Users", etc. Customizable through the map.
- [ ] MFA / Select a number on a pre-logged in device
- [ ] Let admin UI modify roles + permissions for each user
- [ ] max login sessions
    - delete oldest ones limit is reached
    - don't delete trusted device sessions
- [ ] Encrypt User info
    - Allow specific User interface keys to be encrypted before getting sent to the database
        - Make this dynamic so any struct can also have explicit encryption
        - Maybe do this with custom struct metadata tags, e.g. `Address string 'encrypt:"true"'`
            - The custom Mongo handler would check if encryption is enabled, and if so, use the specified `CryptoEngine{}` to encrypt/decrypt data automatically
    - HashiCorp Vault integration
        - Use "derived keys" so each item has a unique encryption key
- [ ] Track IP of each login
    - Attach to session token, if it changes require a relogin
        - Maybe only require a relogin for specific privilege levels (like administrators) to help aid in times where IPs may be changing frequently (a user on cell data)
    - Once a session is expired, log it as "IPs used" to track suspicion level of new logins.
- [ ] Auto-renew session tokens
    - Issue a Refresh token with each session token.
        - Refreshing the session would require a valid Session Token + Refresh Token.
        - It will use and give a new refresh token if the user logs in during a valid time period before the session token expires (e.g. 7 days until expiration)
    - Customizable settings in `SecureEndpointMiddleware`:
        - Enable feature
            - Only enable if they are a specific role (e.g. maybe let `users` refresh automatically, but require `admins` to login)
                - Maybe let `users` disable this if they'd like to enhance their own security
        - Session-based refresh period (how long before the token expires should a new one be issued?)
- [ ] Login sus levels
    - Using IP data, create a "trust" level based on if the IP being used to login has been used before, approx. geolocation difference from commonly used IPs, etc.
- [ ] Maximum Username and Password lengths to prevent overflow attacks (?). It should be large for passwords- like 256, and shorter for usernames (maybe 64 by default)
    - Can be modified on `RegistrationHandler{}`
- [ ] Sign tokens
- [ ] Create a flag for the Login API to return verbose error messages (username incorrect / password incorrect) or secure messages ("username or password incorrect")
    - This needs to also reflect status codes getting sent.
- [ ] Inherited encrypted values on registration
    - e.g. for kanban board, automatically give new users access to the HashiCorp Vault API key (maybe different keys for each user?) and encrypt w/ user password.
        - admin adds a new user -> admin creates a new encryption key in HashiCorp Vault -> admin encrypts their copy of the real API key with ephemeral hashicorp key -> send encrypted key to frontend registration -> frontend registration encrypts key w/ password -> key gets sent with registration
- [ ] Federated Logins (Google, Google Workspace, etc)
- [ ] Tailscale authentication
    - Somehow make it toggleable per endpoint maybe ??
        - Or just make it a completely separate isolated area
    - If you're connected to Tailscale, authorize with that and leave permissions as-is (attach tailscale hostname/IP to a username w/ permissions)
- [ ] Become an OAuth provider (allow external apps to authenticate with this service)
- [ ] Prometheus Support (exports basic metrics: # users, # login attempts, # failed logins, etc)
- [ ] Audit Logging system (easily create audit logs, allow apps to push to said audit log)
- [ ] API Token Management
    - Create tokens
    - Delete tokens
    - Track usage
    - API Token validation middleware to only allow specific endpoints to be hit if the token has a role associated
- [ ] Support user profile icons
- [ ] Email verification for new users
- [ ] Make roles & permissions editable on the UI
- [ ] Store a "preferred language" for each user for i18n
- [ ] Multi-Tenancy
    - Allow logins to multiple "orgs" within one app.
    - Would relie on a Tenant Interface to allow for customizable tenant info (e.g. logos, branding colors, etc)

## done:
- [x] Launchpad "Restore" button
    - This will reseed the database with entirely new information based on whatever is in the `LocksmithLaunchpadOptions.BootstrapDatabase`
- [x] Change Launchpad background color depending on what environment is in use.
- [x] When using a Launchpad user, inject an HTML header to show what persona the user is currently in
- [x] Launchpad
    - [x] Render different test users on frontend
    - [x] Basic Auth to confirm the user has access to the launchpad
        - Note in the Docs there is now a BasicAuth handler in SecureEndpointHTTPMiddleware
    - [x] Completly disable Launchpad code when built for production
        - You MUST specify the `enable_launchpad` tag when building to get it:
            - BUILD: `go build -o app -tags enable_launchpad`
            - RUN: `go run -tags enable_launchpad main.go`
    - [x] Jump into different user account
    - [x] Dynamic subtitle
- [x] Hash user tokens and invite tokens
    - [x] Hash invite tokens
    - [x] Hash session tokens
- [x] Disable public registration flag
    - Bootstrapping the first user will come once password resets are enabled. It will force you to change the admin password once you login the first time.
    - [x] Set this on `register.RegistrationHandler{}` "DisablePublicRegistration"
- [x] Create users in the Admin UI, they'll need to setup their own password
    - [x] Allow user creation through locksmith.InviteUser(email string) (inviteURL string)
    - [x] HTTP endpoint to call InviteUser from admin dashboard
    - [x] Admin UI integration to invite users
    - This should give them a unique registration link to send to individuals.
        - [x] Register using custom key on /register endpoint (e.g. ?invite=STRING). Hard code to the email into the registration page where it cannot be changed.
- [x] Require email on registration
- [x] Only allow [A-z0-9] in username
- [x] Save token as cookie
- [x] Save username with token in cookie
- [x] Create mongo database tester
- [x] Let registration happen in the Web UI
- [x] Let logins happen in the Web UI
- [x] Deprecate `LocksmithUserFromMap` in favor of `LocksmithUserStruct.ReadFromMap`
    - [x] rename `LocksmithUserStruct` -> `LocksmithUserInterface`
- [x] Token validation middleware
    - Checks if they are expired & valid
- [x] Basic admin panel to view / remove users
    - [x] Backend API
    - [x] Frontend integration
    - [x] User Roles (admin, and customizable roles)
        - [x] Tighten preexisting endpoint security
            - Only let users delete themselves unless they have `users.delete.others` permission
        - [x] Middleware to validate required roles (maybe through context that gets read by token validator middleware?)
            - [x] Rename `ValidateUserTokenMiddleware` to `SecureEndpointMiddleware` which can take a custom `SecureOptions` struct to define allowed roles and such
        - [x] Roles will be hardcoded with privileges in the code, modifiable by changing `roles.AvailableRoles map[string][]string`
